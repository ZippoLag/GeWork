{"version":3,"sources":["fetchWrapper.js","components/App.js","components/cabecera/Cabecera.js","index.js","utils.js"],"names":["baseUrl","process","readUrl","url","startsWith","handleErrors","response","ok","Error","statusText","get","headers","fetch","method","Accept","getCookie","then","json","post","body","JSON","stringify","put","delete","App","state","usuario","exact","path","component","username","Component","Cabecera","className","this","props","Index","instance","httpClient","data","setState","catch","error","console","log","ReactDOM","render","fallback","document","getElementById","cookieName","qualifiedName","cookie","split","find","c","indexOf","replace"],"mappings":"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","file":"static/js/main.074e7de7.chunk.js","sourcesContent":["import getCookie from './utils';\r\n\r\n//TODO: actualmente el backend de django se sirve en el puerto 8000, no obstante deberíamos agregar una forma de automatizar el cambio a donde apuntan las URLs para no deber hacer algo como esto manualmente:\r\nlet baseUrl = '';\r\nif (process) {\r\n  baseUrl =\r\n    process.env.NODE_ENV !== 'production' ? 'http://localhost:8000' : '';\r\n}\r\n\r\n/**\r\n * Si la URL con la que se intenta realizar la request no contiene 'http' ni 'https', entonces se asume que es un fragmento al que debemos agrearle el path inicial\r\n * @param {string}  url url to fetch\r\n **/\r\nconst readUrl = (url = '') =>\r\n  url.startsWith('http://') || url.startsWith('https://')\r\n    ? url\r\n    : baseUrl\r\n    ? `${baseUrl}/${url}`\r\n    : url;\r\n\r\n/**\r\n * Maneja todas las respuestas que no son 200 (OK) como errores\r\n * @param {*} response\r\n */\r\nfunction handleErrors(response) {\r\n  if (!response.ok) {\r\n    throw Error(response.statusText);\r\n  }\r\n  return response;\r\n}\r\n\r\nconst get = (url = '', headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'GET',\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst post = (url = '', body = {}, headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'POST',\r\n    body: JSON.stringify(body),\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst put = (url = '', body = {}, headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'PUT',\r\n    body: JSON.stringify(body),\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst del = (url = '', headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'DELETE',\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nexport default {\r\n  get,\r\n  post,\r\n  put,\r\n  delete: del\r\n};\r\n","import React, { Component } from 'react';\nimport { Route, BrowserRouter as Router } from 'react-router-dom';\n\n//import httpClient from '../fetchWrapper';\n\nimport './App.css';\n\nclass App extends Component {\n  state = {\n    usuario: null\n  }\n\n  componentDidMount(){\n    //let instance = this;\n  }\n\n  //TODO: agregar history al router\n\n  render() {\n    return (\n      <Router>\n        <Route\n          exact\n          path={['/']}\n          component={() => (\n            <div>\n              {this.state.usuario ? `Bienvenidx ${this.state.usuario.username}!` : `Nadie inició sesión aún (o estamos ejecutando mediante 'npm start' por lo que la autenticación de django no nos provée el token)`}\n              <span>Dicho sea de paso, este div debería ser un componente en un .js aparte, si bien no hace falta que implementemos redux, tendríamos que poner toda la data (y los métodos para llamar a la API) en el componente de index y su state y pasarlos como parámetros a los demás; App debería encargarse del routing más que nada</span>\n            </div>\n          )}\n        />\n      </Router>\n    );\n  }\n}\n\nexport default App;\n","import React, { Component } from 'react';\r\nimport Row from 'react-bootstrap/Row';\r\n\r\n//TODO: usar Navbar?\r\n//TODO: revisar que onda los links para react router\r\n\r\nclass Cabecera extends Component {\r\n  state = {\r\n    usuario: null\r\n  }\r\n\r\n  componentDidMount(){\r\n    //let instance = this;\r\n  }\r\n\r\n  //TODO: agregar history al router\r\n\r\n  render() {\r\n    return (\r\n      <Row className='justify-content-between'>\r\n        <div><h1>GeWork</h1></div>\r\n        <div>{this.props.usuario ? this.props.usuario.username : \"Login\"}</div>\r\n      </Row>\r\n    );\r\n  }\r\n}\r\n\r\nexport default Cabecera;\r\n","import React, { Suspense , Component} from 'react';\nimport ReactDOM from 'react-dom';\nimport Container from 'react-bootstrap/Container';\n\nimport App from './components/App';\nimport Cabecera from './components/cabecera/Cabecera'\n\nimport httpClient from './fetchWrapper';\nimport getCookie from './utils';\n\nimport './index.css';\n\nclass Index extends Component {\n  state = {\n    usuario: null\n  }\n\n  componentDidMount(){\n    let instance = this;\n\n    //Si hay un token de autenticación en las cookies del navegador, significa que ya inició sesión un usuario, por lo que podemos obtener sus detalles desde el backend\n    if(getCookie('csrftoken')){\n      httpClient\n        .get(`api/get_detalles_usuario`)\n        .then((data) => {\n          instance.setState({\n            usuario: data\n          });\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n  //TODO: agregar history al router\n\n  render() {\n    return (\n      <Container>\n        <Cabecera usuario={this.state.usuario} />\n        <App usuario={this.state.usuario} />\n      </Container>\n    );\n  }\n}\n\nReactDOM.render(\n  <Suspense fallback=\"Loading..\">\n    <Index />\n  </Suspense>,\n  document.getElementById('root')\n);\n","//Función para obtener una cookie del navegador (más que nada usada para el csrf token de autenticación para django sin tener que implementar una store en redux)\r\nconst getCookie = (cookieName) => {\r\n  let qualifiedName = `${cookieName}=`;\r\n  let cookies = document.cookie.split(';');\r\n  let cookie = cookies.find((c) => {\r\n    return c.indexOf(qualifiedName) === 0;\r\n  });\r\n  cookie = cookie ? cookie.replace(qualifiedName, '') : '';\r\n  return cookie;\r\n};\r\n\r\nexport default getCookie;\r\n"],"sourceRoot":""}