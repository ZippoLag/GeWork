{"version":3,"sources":["fetchWrapper.js","components/App.js","index.js","utils.js"],"names":["baseUrl","process","readUrl","url","startsWith","handleErrors","response","ok","Error","statusText","get","headers","fetch","method","Accept","getCookie","then","json","post","body","JSON","stringify","put","delete","App","state","usuario","instance","this","httpClient","data","setState","catch","error","console","log","exact","path","component","username","Component","ReactDOM","render","fallback","document","getElementById","cookieName","qualifiedName","cookie","split","find","c","indexOf","replace"],"mappings":"8rBAGA,IAAIA,EAAU,GACVC,IACFD,EACoE,IAOtE,IAAME,EAAU,eAACC,EAAD,uDAAO,GAAP,OACdA,EAAIC,WAAW,YAAcD,EAAIC,WAAW,YACxCD,EACAH,EAAO,UACJA,EADI,YACOG,GACdA,GAMN,SAASE,EAAaC,GACpB,IAAKA,EAASC,GACZ,MAAMC,MAAMF,EAASG,YAEvB,OAAOH,EAyDM,KACbI,IAvDU,eAACP,EAAD,uDAAO,GAAIQ,EAAX,uDAAqB,GAArB,OACVC,MAAMV,EAAQC,GAAM,CAClBU,OAAQ,MACRF,QAAQ,EAAD,CACLG,OAAQ,mBACR,eAAgB,oBACbH,EAHE,CAIL,cAAeI,YAAU,iBAG1BC,KAAKX,GACLW,MAAK,SAACV,GAAD,OAAcA,EAASW,WA6C/BC,KA3CW,eAACf,EAAD,uDAAO,GAAIgB,EAAX,uDAAkB,GAAIR,EAAtB,uDAAgC,GAAhC,OACXC,MAAMV,EAAQC,GAAM,CAClBU,OAAQ,OACRM,KAAMC,KAAKC,UAAUF,GACrBR,QAAQ,EAAD,CACLG,OAAQ,mBACR,eAAgB,oBACbH,EAHE,CAIL,cAAeI,YAAU,iBAG1BC,KAAKX,GACLW,MAAK,SAACV,GAAD,OAAcA,EAASW,WAgC/BK,IA9BU,eAACnB,EAAD,uDAAO,GAAIgB,EAAX,uDAAkB,GAAIR,EAAtB,uDAAgC,GAAhC,OACVC,MAAMV,EAAQC,GAAM,CAClBU,OAAQ,MACRM,KAAMC,KAAKC,UAAUF,GACrBR,QAAQ,EAAD,CACLG,OAAQ,mBACR,eAAgB,oBACbH,EAHE,CAIL,cAAeI,YAAU,iBAG1BC,KAAKX,GACLW,MAAK,SAACV,GAAD,OAAcA,EAASW,WAmB/BM,OAjBU,eAACpB,EAAD,uDAAO,GAAIQ,EAAX,uDAAqB,GAArB,OACVC,MAAMV,EAAQC,GAAM,CAClBU,OAAQ,SACRF,QAAQ,EAAD,CACLG,OAAQ,mBACR,eAAgB,oBACbH,EAHE,CAIL,cAAeI,YAAU,iBAG1BC,KAAKX,GACLW,MAAK,SAACV,GAAD,OAAcA,EAASW,c,2QC9BlBO,G,iNA1CbC,MAAQ,CACNC,QAAS,M,mFAIT,IAAIC,EAAWC,KAGZb,YAAU,cACXc,IACGnB,IADH,4BAEGM,MAAK,SAACc,GACLH,EAASI,SAAS,CAChBL,QAASI,OAGZE,OAAM,SAACC,GACNC,QAAQC,IAAIF,Q,+BAKV,IAAD,OACP,OACE,kBAAC,IAAD,KACI,sCACF,kBAAC,IAAD,KACE,kBAAC,IAAD,CACEG,OAAK,EACLC,KAAM,CAAC,KACPC,UAAW,kBACT,6BACG,EAAKb,MAAMC,QAAX,qBAAmC,EAAKD,MAAMC,QAAQa,SAAtD,iK,GAjCCC,cCHlBC,IAASC,OACP,kBAAC,WAAD,CAAUC,SAAS,aACjB,kBAAC,EAAD,OAEFC,SAASC,eAAe,U,+BCAX9B,IAVG,SAAC+B,GACjB,IAAIC,EAAa,UAAMD,EAAN,KAEbE,EADUJ,SAASI,OAAOC,MAAM,KACfC,MAAK,SAACC,GACzB,OAAoC,IAA7BA,EAAEC,QAAQL,MAGnB,OADAC,EAASA,EAASA,EAAOK,QAAQN,EAAe,IAAM,M","file":"static/js/main.8b59579b.chunk.js","sourcesContent":["import getCookie from './utils';\r\n\r\n//TODO: actualmente el backend de django se sirve en el puerto 8000, no obstante deberíamos agregar una forma de automatizar el cambio a donde apuntan las URLs para no deber hacer algo como esto manualmente:\r\nlet baseUrl = '';\r\nif (process) {\r\n  baseUrl =\r\n    process.env.NODE_ENV !== 'production' ? 'http://localhost:8000' : '';\r\n}\r\n\r\n/**\r\n * Si la URL con la que se intenta realizar la request no contiene 'http' ni 'https', entonces se asume que es un fragmento al que debemos agrearle el path inicial\r\n * @param {string}  url url to fetch\r\n **/\r\nconst readUrl = (url = '') =>\r\n  url.startsWith('http://') || url.startsWith('https://')\r\n    ? url\r\n    : baseUrl\r\n    ? `${baseUrl}/${url}`\r\n    : url;\r\n\r\n/**\r\n * Maneja todas las respuestas que no son 200 (OK) como errores\r\n * @param {*} response\r\n */\r\nfunction handleErrors(response) {\r\n  if (!response.ok) {\r\n    throw Error(response.statusText);\r\n  }\r\n  return response;\r\n}\r\n\r\nconst get = (url = '', headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'GET',\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst post = (url = '', body = {}, headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'POST',\r\n    body: JSON.stringify(body),\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst put = (url = '', body = {}, headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'PUT',\r\n    body: JSON.stringify(body),\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nconst del = (url = '', headers = {}) =>\r\n  fetch(readUrl(url), {\r\n    method: 'DELETE',\r\n    headers: {\r\n      Accept: 'application/json',\r\n      'Content-Type': 'application/json',\r\n      ...headers,\r\n      'X-CSRFToken': getCookie('csrftoken')\r\n    }\r\n  })\r\n    .then(handleErrors)\r\n    .then((response) => response.json());\r\n\r\nexport default {\r\n  get,\r\n  post,\r\n  put,\r\n  delete: del\r\n};\r\n","import React, { Component } from 'react';\nimport { Route, BrowserRouter as Router } from 'react-router-dom';\nimport Container from 'react-bootstrap/Container';\n\nimport httpClient from '../fetchWrapper';\n\nimport getCookie from '../utils';\n\nimport './App.css';\n\nclass App extends Component {\n  state = {\n    usuario: null\n  }\n\n  componentDidMount(){\n    let instance = this;\n\n    //Si hay un token de autenticación en las cookies del navegador, significa que ya inició sesión un usuario, por lo que podemos obtener sus detalles desde el backend\n    if(getCookie('csrftoken')){\n      httpClient\n        .get(`api/get_detalles_usuario`)\n        .then((data) => {\n          instance.setState({\n            usuario: data\n          });\n        })\n        .catch((error) => {\n          console.log(error);\n        });\n    }\n  }\n\n  render() {\n    return (\n      <Container>\n          <h1>GeWork</h1>\n        <Router>\n          <Route\n            exact\n            path={['/']}\n            component={() => (\n              <div>\n                {this.state.usuario ? `Bienvenidx ${this.state.usuario.username}!` : `Nadie inició sesión aún (o estamos ejecutando mediante 'npm start' por lo que la autenticación de django no nos provée el token)`}\n              </div>\n            )}\n          />\n        </Router>\n      </Container>\n    );\n  }\n}\n\nexport default App;\n","import React, { Suspense } from 'react';\nimport ReactDOM from 'react-dom';\n\nimport './index.css';\n\nimport App from './components/App';\n\nReactDOM.render(\n  <Suspense fallback=\"Loading..\">\n    <App />\n  </Suspense>,\n  document.getElementById('root')\n);\n","//Función para obtener una cookie del navegador (más que nada usada para el csrf token de autenticación para django sin tener que implementar una store en redux)\r\nconst getCookie = (cookieName) => {\r\n  let qualifiedName = `${cookieName}=`;\r\n  let cookies = document.cookie.split(';');\r\n  let cookie = cookies.find((c) => {\r\n    return c.indexOf(qualifiedName) === 0;\r\n  });\r\n  cookie = cookie ? cookie.replace(qualifiedName, '') : '';\r\n  return cookie;\r\n};\r\n\r\nexport default getCookie;\r\n"],"sourceRoot":""}